// Assume that the LinkedList struct redirects it subscripting to LinkedList.objects

function findTail(L: LinkedList) -> Handle {
    either (let currentObject = L[L.head]) or return None
    while (True) {
        let currentIndex = currentObject.next
        either (let currentObject = L[currentIndex]) or return currentIndex
    }
}

/* Really, modifying a simple object in place is the same as replacing it.
   So, simple objects don't really need single ownership within a single scope,
   as you can use immutable variables and shadowing to avoid shared mutability.
   What's more important is the way modifying compound objects (eg. arrays, structs) is handled.

   When a compound object is stored in a "let", its members cannot be replaced. 
 */


function removeTail(mutate L: LinkedList) {
    either (let currentObject = L[L.head]) or return
    while (True) {
        let currentIndex = currentObject.next
        either (let currentObject = L[currentIndex]) or break
    }
    run L.delete!(currentIndex)
}

// Error: what happens to currentObject after L.delete!(currentIndex) ?