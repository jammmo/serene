// Idea: plug in type variable to function instead of value to yield return type?
// Potentially some ambiguity/confusion there but definitely useful

// Could use 'A instead of #A

func elementInArray(move elem: #T, arr: Array(#T)) -> Option(#T) {
    for i in range(arr.length) {
        if arr[i] == elem {
            return elem;
        }
    }

    return None;
}

// Where statement
func elementInArray(move elem: #A, arr: #B) -> #A where
    #A: Simple,
    #B: Array(#A) {

    for i in range(arr.length) {
        if arr[i] == elem {
            return elem;
        }
    }

    return None;
}

//This one is ugly - too many things in one line
func elementInArray(move elem: #A --Simple, arr: #B --Array(#A)) -> #A {
    for i in range(arr.length) {
        if arr[i] == elem {
            return elem;
        }
    }

    return None;
}

// Supertype, type, subtype
^Simple
'Person
\Woman


//for methods

interface CompareAndIndex(self: type X) {
    method lessThan(other: X) -> bool;
    method greaterThan(other: X) -> bool;

    self[index: int] -> Option(X);
}

//or for regular functions

interface CompareAndIndex(self: type X) {
    function lessThan(self: X, other: X) -> bool;
    function greaterThan(self: X, other: X) -> bool;

    self[index: int] -> Option(X);
}



implement CompareAndIndex(self: Array(int)) {
    method lessThan(other: Array(int)) {
        for (i in 0 .. min(self.length, other.length)) {
            if (self[i] != other[i]) {
                return self[i] < other[i];
            }
        }
        return self.length < other.length;
    }

    method lessThan(other: Array(int)) {
        for (i in 0 .. min(self.length, other.length)) {
            if (self[i] != other[i]) {
                return self[i] > other[i];
            }
        }
        return self.length > other.length;
    }

    self[index: int] from Index(self: Array(type X));
}