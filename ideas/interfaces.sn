import AddressModule

interface Card with
~ struct {
    returnAddress: String
}

interface Invitation with
~ struct {
    date: String,
    location: Address,
    numGuests: Int,
    accepted: Bool
}

~ signatures {
    method send(recipient: Person),
    method accept(guests: Int)
}

type WeddingInvitation with
~ struct {
    bride: String,
    groom: String,
    struct from Invitation,
    struct from Card
}

~ specifics (implements Invitation) {
    method send(recipient: Person) {
        run recipient.receive(copy self)
    }

    method accept(guests: Int) {
        set self.accepted = True
    }

    method parseLocation(address: String) from AddressModule
}



// Interfaces with generics?

interface CompareAndIndex(self: type X) with
~ signatures {
    method lessThan(other: X) -> bool
    method greaterThan(other: X) -> bool

    subscript get(index: int) -> Option(X)
}
~ specifics where X: Array(int) {
    method lessThan(other: Array(int)) {
        for (i in 0 .. min(self.length, other.length)) {
            if (self[i] != other[i]) {
                return self[i] < other[i]
            }
        }
        return self.length < other.length
    }

    method lessThan(other: Array(int)) {
        for (i in 0 .. min(self.length, other.length)) {
            if (self[i] != other[i]) {
                return self[i] > other[i]
            }
        }
        return self.length > other.length
    }

    subscript get(index: int) -> Option(int) from Index(self: Array(type X))
}