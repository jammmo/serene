// Potential implementation of the Pool and Noodle system as a standard library module
// Assume that array is variable length

// needs to be an Optional type


type Noodle(type MyPool) with
~ friend Pool
~ struct {
    index: int private
}


type Pool with
~ constructor(type T) {
    set self.array = Array(T)
    type Noodle = Noodle(typeof self)
}
~ struct {
    array: Array(T) private,
}
~ specifics {
    method add(NewValue: type T) -> Noodle {
        run array.append(NewValue)
        let noodle = Noodle()
        return noodle
    }

    method delete(IndexToDelete: Noodle) {
        run array.pop!(IndexToDelete)
    }

    subscript get(MyNoodle: Noodle) -> Noodle {
        return array[MyNoodle.index]
    }
}

// Note that all T's here are the same. Need a better way to make that clear...


// Which to use?
type Noodle = something()
const Noodle: type = something()