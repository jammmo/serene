{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"#introduction","text":"Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"00_Why_Serene/","text":"Why Serene? \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2014Martin Fowler, 1999 If you do a Google search for \"What programming language should people learn first?\" in 2021, you'll see a lot of results for Python. Indeed, my first college computer science class several years ago was taught in Python, after they had switched from teaching MATLAB in previous years. While systems programming languages like C and C++ continue to be widely used within the industry, they are often taught later on and seen to be more difficult than high level languages like Python. The term \"systems programming language\" has always been a bit vague, as many of the characteristic features, like static type checking, efficient optimizing compilers, support for concurrency, and low-overhead memory management, are still desirable for all kinds of general purpose programming. These advantages may lead one to wonder why systems programming languages aren't taught and used everywhere. But Python, which lacks nearly all these features, continues to be a popular choice for both beginners and for fast prototyping of applications due to better readability. Python's syntax often closely mirrors a natural English description of a process, while C is dense with symbols and abbreviations. But beyond syntax, the complexity of manual memory management in C can lead to a mismatch between how someone's code actually behaves and how they expect it to behave, and the language has few safeguards to prevent you from breaking things. Rust, a newer systems programming language, introduced a new memory management system based around ownership of objects, which provides those safeguards by default. But it is still quite complex, and an inaccurate mental model of how the system works can lead to a frustrating experience trying to get your code to compile. Serene is a systems programming language designed to be naturally understood. It uses an ownership-based memory management system inspired by Rust, but it constrains the system to a simpler subset of the same idea. It uses keywords instead of symbols for common operations, and it has a minimalist design so there are less concepts to memorize. Serene is rather strict about its rules, but that leads to a consistent and organized procedural style for all of its code, where one can read and understand each function independently of any other code. It is the goal of the language to make the process of developing high performance software effortless, enjoyable, and\u2014well, serene.","title":"Why Serene?"},{"location":"00_Why_Serene/#why-serene","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2014Martin Fowler, 1999 If you do a Google search for \"What programming language should people learn first?\" in 2021, you'll see a lot of results for Python. Indeed, my first college computer science class several years ago was taught in Python, after they had switched from teaching MATLAB in previous years. While systems programming languages like C and C++ continue to be widely used within the industry, they are often taught later on and seen to be more difficult than high level languages like Python. The term \"systems programming language\" has always been a bit vague, as many of the characteristic features, like static type checking, efficient optimizing compilers, support for concurrency, and low-overhead memory management, are still desirable for all kinds of general purpose programming. These advantages may lead one to wonder why systems programming languages aren't taught and used everywhere. But Python, which lacks nearly all these features, continues to be a popular choice for both beginners and for fast prototyping of applications due to better readability. Python's syntax often closely mirrors a natural English description of a process, while C is dense with symbols and abbreviations. But beyond syntax, the complexity of manual memory management in C can lead to a mismatch between how someone's code actually behaves and how they expect it to behave, and the language has few safeguards to prevent you from breaking things. Rust, a newer systems programming language, introduced a new memory management system based around ownership of objects, which provides those safeguards by default. But it is still quite complex, and an inaccurate mental model of how the system works can lead to a frustrating experience trying to get your code to compile. Serene is a systems programming language designed to be naturally understood. It uses an ownership-based memory management system inspired by Rust, but it constrains the system to a simpler subset of the same idea. It uses keywords instead of symbols for common operations, and it has a minimalist design so there are less concepts to memorize. Serene is rather strict about its rules, but that leads to a consistent and organized procedural style for all of its code, where one can read and understand each function independently of any other code. It is the goal of the language to make the process of developing high performance software effortless, enjoyable, and\u2014well, serene.","title":"Why Serene?"},{"location":"01_Functions/","text":"1. Functions Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { print \"Hello world!\" } In Serene, the body of a function is a sequence of statements, each beginning with a keyword. Let's define another function that takes a parameter and also returns a value. The invert function is pretty trivial, but it shows what a typical function signature looks like. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return ( not b) } function main () { run invert( True ) //return value is discarded print invert( True ) //return value is printed } Remember that the body of a function is a sequence of statements: invert(True) on its own isn't a statement, so we use the run keyword to execute it.","title":"1. Functions"},{"location":"01_Functions/#1-functions","text":"Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { print \"Hello world!\" } In Serene, the body of a function is a sequence of statements, each beginning with a keyword. Let's define another function that takes a parameter and also returns a value. The invert function is pretty trivial, but it shows what a typical function signature looks like. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return ( not b) } function main () { run invert( True ) //return value is discarded print invert( True ) //return value is printed } Remember that the body of a function is a sequence of statements: invert(True) on its own isn't a statement, so we use the run keyword to execute it.","title":"1. Functions"},{"location":"02_Variables_Types_And_Math/","text":"2. Variables, Types, and Math You can store a value with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). The value of a variable can be modified after it is created with the keyword set , but the value of a constant can never change. Note that variables and constants must be defined inside of functions, and they are locally scoped: that is, they are only valid in the scope in which they are declared. When that scope ends, all of its local values will be deleted and the associated memory will be freed. function test1 () { const age: Int = 20 print age //age can't be changed here! } function test2 () { var age: Int = 20 print age set age = 21 print age set age = age + 1 print age set age += 1 //same as: set age = age + 1 print age } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height print area, \" inches\" } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable print name }","title":"2. Variables, Types, and Math"},{"location":"02_Variables_Types_And_Math/#2-variables-types-and-math","text":"You can store a value with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). The value of a variable can be modified after it is created with the keyword set , but the value of a constant can never change. Note that variables and constants must be defined inside of functions, and they are locally scoped: that is, they are only valid in the scope in which they are declared. When that scope ends, all of its local values will be deleted and the associated memory will be freed. function test1 () { const age: Int = 20 print age //age can't be changed here! } function test2 () { var age: Int = 20 print age set age = 21 print age set age = age + 1 print age set age += 1 //same as: set age = age + 1 print age } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height print area, \" inches\" } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable print name }","title":"2. Variables, Types, and Math"},{"location":"03_Mutability_And_Ownership/","text":"3. Mutability and Ownership Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming. How to Manage Mutability and Ownership You've already seen const , which allows you to create a locally-scoped constant, and var , which allows to create a locally-scoped variable (that can be mutated with set ). Now let's talk about the other place where mutability is important: function parameters. When passing a value to a function, there are four ways you can do it. You need to specify which one to use both where the function is defined and where it is called, using accessor keywords. Let's look at the four different accessors one by one. look : Look is the default behavior for function parameters, so there's no keyword required. It passes a value to a function immutably, meaning that the value cannot be altered anywhere in the function, regardless of whether the value you are passing is a literal value, a var , or a const . This also means that if function a() takes a value by look , function a() can't pass that value to a function b() that takes it by mutate or move . It can, however, pass that value to another function by copy , as copying a value leaves the original value unaffected. mutate : Mutate effectively \"borrows\" the value from its original scope, allowing it to be mutated within the function as if it is a local variable. Once the function returns, ownership of the (now modified) value will return to the original scope. mutate is really the only place that aliasing behavior (where mutating one variable also mutates another) exists in Serene. This behavior can be confusing in other languages (which is part of why Serene doesn't have pointers), but Serene makes the behavior explicit to the reader by requiring the keyword mutate both where the function is defined and where it is called. Note that you can't past a constant ( const ) as a mutate parameter, as once a constant is created, it can never be mutated. Also if function a() takes a value by mutate , function a() still can't pass that value to a function b() that takes it by move , as the value must still exist when the function returns. move : If you've used Rust or modern C++, you've probably heard of Move semantics. move transfers ownership of an object from one scope to another. If you pass a variable to a function by move , that variable won't exist anymore when the function returns. You can move both variables and constants. If you move a variable into a function, that function will be able to mutate the variable with set , just as if it was declared locally. copy : Copy does exactly what it sounds like: it copies the original value and passes the copied value to the function. The original value will be unaffected and it will still be owned by the original scope, while the new value will be owned by the new scope. It's worth mentioning at this point that all four of these accessors describe the user-level semantic behavior, but not necessarily the way that the program will execute at the hardware level. The Serene compiler will optimize the program, and part of that process is removing unnecessary copies. So if you pass a large object by copy but then you never mutate it, the compiler will be smart enough to not waste memory by copying the object and to just use a pointer to the original object. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int (length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { // Exclamation marks are required for methods that mutate the object they act on run s.delete!(i) } else { set i += 1 } } } function sortedCopy ( copy s: String ) -> String { run s.sort!() // s is a copy of the original input, so the original input is not modified return s } // consumes a character array and returns it as a string function charArrayToString ( move u: Array { Char }) -> String { var s = \"\" for (x in u) { s.append!(x) } return s } function main () { const name = \"Matthew\" var letter = ' ' run middleChar(name, mutate letter) var new_name = name // copies name run removeChar( mutate new_name, c) const mixed_up = \"edcabfg\" print sortedCopy( copy mixed_up) // mixed_up is not modified var u_array = Array ( 'h' , 'e' , 'l' , 'l' , 'o' ) var u_string = charArrayToString( move u_array) print typeof(u_string) // prints String // u_array no longer exists here }","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#3-mutability-and-ownership","text":"Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#how-to-manage-mutability-and-ownership","text":"You've already seen const , which allows you to create a locally-scoped constant, and var , which allows to create a locally-scoped variable (that can be mutated with set ). Now let's talk about the other place where mutability is important: function parameters. When passing a value to a function, there are four ways you can do it. You need to specify which one to use both where the function is defined and where it is called, using accessor keywords. Let's look at the four different accessors one by one. look : Look is the default behavior for function parameters, so there's no keyword required. It passes a value to a function immutably, meaning that the value cannot be altered anywhere in the function, regardless of whether the value you are passing is a literal value, a var , or a const . This also means that if function a() takes a value by look , function a() can't pass that value to a function b() that takes it by mutate or move . It can, however, pass that value to another function by copy , as copying a value leaves the original value unaffected. mutate : Mutate effectively \"borrows\" the value from its original scope, allowing it to be mutated within the function as if it is a local variable. Once the function returns, ownership of the (now modified) value will return to the original scope. mutate is really the only place that aliasing behavior (where mutating one variable also mutates another) exists in Serene. This behavior can be confusing in other languages (which is part of why Serene doesn't have pointers), but Serene makes the behavior explicit to the reader by requiring the keyword mutate both where the function is defined and where it is called. Note that you can't past a constant ( const ) as a mutate parameter, as once a constant is created, it can never be mutated. Also if function a() takes a value by mutate , function a() still can't pass that value to a function b() that takes it by move , as the value must still exist when the function returns. move : If you've used Rust or modern C++, you've probably heard of Move semantics. move transfers ownership of an object from one scope to another. If you pass a variable to a function by move , that variable won't exist anymore when the function returns. You can move both variables and constants. If you move a variable into a function, that function will be able to mutate the variable with set , just as if it was declared locally. copy : Copy does exactly what it sounds like: it copies the original value and passes the copied value to the function. The original value will be unaffected and it will still be owned by the original scope, while the new value will be owned by the new scope. It's worth mentioning at this point that all four of these accessors describe the user-level semantic behavior, but not necessarily the way that the program will execute at the hardware level. The Serene compiler will optimize the program, and part of that process is removing unnecessary copies. So if you pass a large object by copy but then you never mutate it, the compiler will be smart enough to not waste memory by copying the object and to just use a pointer to the original object. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int (length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { // Exclamation marks are required for methods that mutate the object they act on run s.delete!(i) } else { set i += 1 } } } function sortedCopy ( copy s: String ) -> String { run s.sort!() // s is a copy of the original input, so the original input is not modified return s } // consumes a character array and returns it as a string function charArrayToString ( move u: Array { Char }) -> String { var s = \"\" for (x in u) { s.append!(x) } return s } function main () { const name = \"Matthew\" var letter = ' ' run middleChar(name, mutate letter) var new_name = name // copies name run removeChar( mutate new_name, c) const mixed_up = \"edcabfg\" print sortedCopy( copy mixed_up) // mixed_up is not modified var u_array = Array ( 'h' , 'e' , 'l' , 'l' , 'o' ) var u_string = charArrayToString( move u_array) print typeof(u_string) // prints String // u_array no longer exists here }","title":"How to Manage Mutability and Ownership"},{"location":"04_Collections/","text":"4. Collections In this section, we will learn about several more complex types that are built into Serene. Arrays An array is a fixed-length sequence elements, where all of the elements are the same type. If the index is invalid, the indexing operation will return undefined , which is a special value (actually, it's not a value) that will be introduced later, in the Expressing Nothing section. You specify what the types of elements are by using generics. We'll explain more about generics later, but for now it suffices to say that when describing a generic type like an array, you put the type of its elements in curly braces. So Array{Float} would be an array of floating-point numbers. However, generic types are still constructed like other objects, using the type's name followed by parameters in parenthesis (eg. Array(0.1, 0.2, 0.3) ). // returns the index of the leftmost occurence of x, or the next lowest number if x is not found // Array u must be already sorted function binarySearch (u: Array { Int }, x: Int ) -> Int { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 // integer division either (u[mid] is defined ) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } return low } function main () { var u = Array (5, 1, 4, -3, 9, 0) run u.sort!() print binarySearch(u, 4) } Vectors An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . // deletes the leftmost occurence of x, or does nothing if x is not found // Vector u must be already sorted function binarySearchAndDelete ( mutate u: Vector { Int }, x: Int ) { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 either (u[mid] is defined ) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } if (u[low] == x) { run u.delete!(low) } } function main () { var u = Vector ( Int ) // creates an empty vector of integers print \"Length of u: \" , u.length // Length of u: 0 for (i = 0, 5) { u.append!(i * 2) } print \"Length of u: \" , u.length // Length of u: 5 print u // [0, 2, 4, 6, 8] print binarySearch(u, 6) // 3 } Regions (and Handles) A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region ( String ) const first_name = reg.add!( \"Neil\" ) const middle_name = reg.add!( \"Patrick\" ) const last_name = reg.add!( \"Harris\" ) print reg[first_name] print reg[middle_name] print reg[last_name] } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region { String } { var reg = Region ( String ) const first_name = reg.add!( \"Neil\" ) const middle_name = reg.add!( \"Patrick\" ) const last_name = reg.add!( \"Harris\" ) return reg }","title":"4. Collections"},{"location":"04_Collections/#4-collections","text":"In this section, we will learn about several more complex types that are built into Serene.","title":"4. Collections"},{"location":"04_Collections/#arrays","text":"An array is a fixed-length sequence elements, where all of the elements are the same type. If the index is invalid, the indexing operation will return undefined , which is a special value (actually, it's not a value) that will be introduced later, in the Expressing Nothing section. You specify what the types of elements are by using generics. We'll explain more about generics later, but for now it suffices to say that when describing a generic type like an array, you put the type of its elements in curly braces. So Array{Float} would be an array of floating-point numbers. However, generic types are still constructed like other objects, using the type's name followed by parameters in parenthesis (eg. Array(0.1, 0.2, 0.3) ). // returns the index of the leftmost occurence of x, or the next lowest number if x is not found // Array u must be already sorted function binarySearch (u: Array { Int }, x: Int ) -> Int { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 // integer division either (u[mid] is defined ) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } return low } function main () { var u = Array (5, 1, 4, -3, 9, 0) run u.sort!() print binarySearch(u, 4) }","title":"Arrays"},{"location":"04_Collections/#vectors","text":"An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . // deletes the leftmost occurence of x, or does nothing if x is not found // Vector u must be already sorted function binarySearchAndDelete ( mutate u: Vector { Int }, x: Int ) { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 either (u[mid] is defined ) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } if (u[low] == x) { run u.delete!(low) } } function main () { var u = Vector ( Int ) // creates an empty vector of integers print \"Length of u: \" , u.length // Length of u: 0 for (i = 0, 5) { u.append!(i * 2) } print \"Length of u: \" , u.length // Length of u: 5 print u // [0, 2, 4, 6, 8] print binarySearch(u, 6) // 3 }","title":"Vectors"},{"location":"04_Collections/#regions-and-handles","text":"A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region ( String ) const first_name = reg.add!( \"Neil\" ) const middle_name = reg.add!( \"Patrick\" ) const last_name = reg.add!( \"Harris\" ) print reg[first_name] print reg[middle_name] print reg[last_name] } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region { String } { var reg = Region ( String ) const first_name = reg.add!( \"Neil\" ) const middle_name = reg.add!( \"Patrick\" ) const last_name = reg.add!( \"Harris\" ) return reg }","title":"Regions (and Handles)"},{"location":"05_Control_Flow/","text":"5. Control Flow So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs. Conditional Statements A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) -> Int { if (x < 0) { return -x } else { return x } } Loops Serene has two looping constructs: \"for loops\" and \"while loops\". function findMax (u: Vector { Int }) -> Int { var max = Int .bottom //lowest possible Int value for (x in u) { //iterates through the elements of u if (x > max) { set max = x } } } function findMax2 (u: Vector { Int }) -> Int { var max = Int .bottom for (i = 0, u.length) { //iterates from 0 up to (but not including) the length of u // Compiler automatically checks that u[i] is not undefined by verifying the loop bounds if (u[i] > max) { set max = u[i] } } } function findMax3 (u: Vector { Int }) -> Int { var max = Int .bottom var i: Int = 0 while (i < u.length) { if (u[i] > max) { set max = u[i] } } } Match A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while ( True ) { var input = readLine() match (input) { \"\" -> continue \"y\" , \"Y\" -> return True \"n\" , \"N\" -> return False else -> { print \"Input is invalid, try again\" continue } } } } More Control Flow There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"5. Control Flow"},{"location":"05_Control_Flow/#5-control-flow","text":"So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs.","title":"5. Control Flow"},{"location":"05_Control_Flow/#conditional-statements","text":"A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) -> Int { if (x < 0) { return -x } else { return x } }","title":"Conditional Statements"},{"location":"05_Control_Flow/#loops","text":"Serene has two looping constructs: \"for loops\" and \"while loops\". function findMax (u: Vector { Int }) -> Int { var max = Int .bottom //lowest possible Int value for (x in u) { //iterates through the elements of u if (x > max) { set max = x } } } function findMax2 (u: Vector { Int }) -> Int { var max = Int .bottom for (i = 0, u.length) { //iterates from 0 up to (but not including) the length of u // Compiler automatically checks that u[i] is not undefined by verifying the loop bounds if (u[i] > max) { set max = u[i] } } } function findMax3 (u: Vector { Int }) -> Int { var max = Int .bottom var i: Int = 0 while (i < u.length) { if (u[i] > max) { set max = u[i] } } }","title":"Loops"},{"location":"05_Control_Flow/#match","text":"A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while ( True ) { var input = readLine() match (input) { \"\" -> continue \"y\" , \"Y\" -> return True \"n\" , \"N\" -> return False else -> { print \"Input is invalid, try again\" continue } } } }","title":"Match"},{"location":"05_Control_Flow/#more-control-flow","text":"There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"More Control Flow"},{"location":"06_Expressing_Nothing/","text":"6. Expressing Nothing In Serene, there are a couple ways of expressing that something does not exist. Maybe (Defined and Undefined) The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values (instead, one might describe them as \"states\" of a value). This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but variables and function parameters cannot be undefined. So once you return a maybe , you are required to check whether it's defined before doing anything useful with it, but once you have checked it, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } } // This is equivalent to the first definition, as indexing a String (and most other collections) // returns a \"maybe\" type. Note that leaving out \"maybe\" would cause a compile-time error function getFirst2 (u: String ) -> maybe Char { return u[0] } Cell While it isn't present for maybe types, the \"unwrapping\" behavior of an object that may or may not exist is still useful in certain situations, like when defining a recursive type such as the Node type we will see in the next section. Serene provides the Cell type, which can be unwrapped into either Some(x) or None . All the usual ownership rules still apply to Cells: a Cell owns whatever value it holds, so you can't have two Cells holding the same value. The main difference between a Cell and a maybe is that a Cell is an actual value, so it can be stored in a variable or passed to a function. maybe is mainly used by standard library types as a safety mechanism to detect indexing errors at compile time instead of runtime. But Cells can be used anywhere as an object that can hold (or not hold) another object. function printNickname (p: Person ) { match (p.nickname) { Some (name) -> print \"Your nickname is \" , name, \".\" None -> print \"No nickname is set.\" } } Either The either statement is a control flow construct that is used in conjunction with maybe types. It allows you to execute a statement conditionally based on whether the values needed are defined. Here is an example of using the indexing operator with a HashMap . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating map ) and it would instead execute the second statement, after the keyword or . // Update the value for a key in a HashMap, only if the key is present function updateValueAtKey (value: Float , key: String , mutate map: HashMap { String , Float }) { either ( set map[key] = value) or return }","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#6-expressing-nothing","text":"In Serene, there are a couple ways of expressing that something does not exist.","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#maybe-defined-and-undefined","text":"The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values (instead, one might describe them as \"states\" of a value). This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but variables and function parameters cannot be undefined. So once you return a maybe , you are required to check whether it's defined before doing anything useful with it, but once you have checked it, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } } // This is equivalent to the first definition, as indexing a String (and most other collections) // returns a \"maybe\" type. Note that leaving out \"maybe\" would cause a compile-time error function getFirst2 (u: String ) -> maybe Char { return u[0] }","title":"Maybe (Defined and Undefined)"},{"location":"06_Expressing_Nothing/#cell","text":"While it isn't present for maybe types, the \"unwrapping\" behavior of an object that may or may not exist is still useful in certain situations, like when defining a recursive type such as the Node type we will see in the next section. Serene provides the Cell type, which can be unwrapped into either Some(x) or None . All the usual ownership rules still apply to Cells: a Cell owns whatever value it holds, so you can't have two Cells holding the same value. The main difference between a Cell and a maybe is that a Cell is an actual value, so it can be stored in a variable or passed to a function. maybe is mainly used by standard library types as a safety mechanism to detect indexing errors at compile time instead of runtime. But Cells can be used anywhere as an object that can hold (or not hold) another object. function printNickname (p: Person ) { match (p.nickname) { Some (name) -> print \"Your nickname is \" , name, \".\" None -> print \"No nickname is set.\" } }","title":"Cell"},{"location":"06_Expressing_Nothing/#either","text":"The either statement is a control flow construct that is used in conjunction with maybe types. It allows you to execute a statement conditionally based on whether the values needed are defined. Here is an example of using the indexing operator with a HashMap . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating map ) and it would instead execute the second statement, after the keyword or . // Update the value for a key in a HashMap, only if the key is present function updateValueAtKey (value: Float , key: String , mutate map: HashMap { String , Float }) { either ( set map[key] = value) or return }","title":"Either"},{"location":"07_Custom_Types/","text":"7. Custom Types Types in Serene can be defined using the type keyword, as shown below. You can use this format to define structs, enums, and tuples. type Person struct { age: Int , name: String , nickname: Cell { String } } type Point3D tuple { Int , Int , Int } type Address tuple { Int , // House number String , // Street name } type RainbowColors enum { Red , Orange , Yellow , Green , Blue , Purple } function main () { var jason = Person (41, \"Jason Segel\" , Cell ( \"Marshall\" )) set jason.nickname = None var color = RainbowColors :: Red set color = RainbowColors :: Green } Linked List Example Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it. Internally, it stores data as a struct, but instead of passing the fields of the struct directly, the user will pass arguments to a constructor function which will create and initialize the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. This format is called a \"constructed type\". Another new thing here is private fields, which can't be accessed from outside of the type's definition. However, a type can give special permission for another type to access its private fields by declaring it a friend type, as we will see later. // Linked list of integers // Possibly some ownership issues here type Node struct { data: Int , next: Cell { Node } } type LinkedList with ~ constructor (first: Int ) { // To be able to represent an empty list, the head must be in a Cell var self.head private = Cell ( Node (first, None )) } ~ specifics { method addFirst !(a: Int ) { // This method mutates the object, so the exclamation point is required set self.head = Node (a, move self.head) } method popFirst !() -> maybe Int { if (self.head is None ) return undefined var x = self.head.data // note that this copies self.head.data set self.head = self.head.next return x } method append !(a: Int ) { if (self.head is None ) { set self.head = Node (a, None ) } else { var x = self.head while (x.next is not None ) { set x = x.next } set x.next = Node (a, None ) } } method empty () -> Bool { return (self.head is None ) } }","title":"7. Custom Types"},{"location":"07_Custom_Types/#7-custom-types","text":"Types in Serene can be defined using the type keyword, as shown below. You can use this format to define structs, enums, and tuples. type Person struct { age: Int , name: String , nickname: Cell { String } } type Point3D tuple { Int , Int , Int } type Address tuple { Int , // House number String , // Street name } type RainbowColors enum { Red , Orange , Yellow , Green , Blue , Purple } function main () { var jason = Person (41, \"Jason Segel\" , Cell ( \"Marshall\" )) set jason.nickname = None var color = RainbowColors :: Red set color = RainbowColors :: Green }","title":"7. Custom Types"},{"location":"07_Custom_Types/#linked-list-example","text":"Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it. Internally, it stores data as a struct, but instead of passing the fields of the struct directly, the user will pass arguments to a constructor function which will create and initialize the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. This format is called a \"constructed type\". Another new thing here is private fields, which can't be accessed from outside of the type's definition. However, a type can give special permission for another type to access its private fields by declaring it a friend type, as we will see later. // Linked list of integers // Possibly some ownership issues here type Node struct { data: Int , next: Cell { Node } } type LinkedList with ~ constructor (first: Int ) { // To be able to represent an empty list, the head must be in a Cell var self.head private = Cell ( Node (first, None )) } ~ specifics { method addFirst !(a: Int ) { // This method mutates the object, so the exclamation point is required set self.head = Node (a, move self.head) } method popFirst !() -> maybe Int { if (self.head is None ) return undefined var x = self.head.data // note that this copies self.head.data set self.head = self.head.next return x } method append !(a: Int ) { if (self.head is None ) { set self.head = Node (a, None ) } else { var x = self.head while (x.next is not None ) { set x = x.next } set x.next = Node (a, None ) } } method empty () -> Bool { return (self.head is None ) } }","title":"Linked List Example"},{"location":"08_Interfaces/","text":"8. Interfaces When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. interface Invitation with ~ signatures { method send (recipient: Person ) method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , date: String , location: Address , numGuests: Int , accepted: Bool } ~ specifics ( implements Invitation ) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } // Use implementation of method from a separate module method parseLocation (address: String ) from Address }","title":"8. Interfaces"},{"location":"08_Interfaces/#8-interfaces","text":"When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. interface Invitation with ~ signatures { method send (recipient: Person ) method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , date: String , location: Address , numGuests: Int , accepted: Bool } ~ specifics ( implements Invitation ) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } // Use implementation of method from a separate module method parseLocation (address: String ) from Address }","title":"8. Interfaces"},{"location":"09_Generic_Functions/","text":"9. Generic Functions Serene supports both generic functions and generic types. What does that mean? Well, let's start with generic functions, which allow you to write a function without knowing the types of its parameters and return values in advance. You can later specify them when the function is called. In C++, you might see generics that look something like std::make_unique<Node>(data) , where you pass two sets of parameters: the type information in angle brackets, and the initialization data for the constructor in parenthesis. In Serene, you use curly braces instead of angle brackets for the type parameters in the function definition, but you should never actually see both sets of parameters written together when the function is called, as the type parameters are always either inferred or passed explicitly as regular arguments. As we'll see in the next section, the same is true for generic types: you might want to create an array whose type is Array{Int} , but you would initialize it using its constructor (eg. Array(1, 2, 3) ) and the type parameters would be inferred. ( Array{Int}(1, 2, 3) is invalid syntax.) Generic parameters are types, so they must be start with capital letters like any other type in Serene, and they are specified using the type keyword, like in the example below. function elementInArray { T : type } ( move elem: T , arr: Array { T }) -> maybe T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray2 { A : type , B type } ( move elem: A , arr: B ) -> maybe A where A : Simple , B : Array { A } { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } function makeEmptyCellVector { T : type } ( T : type ) -> Vector { Cell { T }} { return Vector ( Cell { T }) // The constructor for vectors allows you to pass a type explicitly } function main () { var a = makeEmptyCellVector( Int ) print a // Prints [] run a.append!( None ) print a // Prints [None] run a.append!(18) print a // Prints [None, 18] var u = Array (1, 3, 5, 7) either ( print elementInArray(5, u)) or print \"Could not be found\" either ( print elementInArray2(7, u)) or print \"Could not be found\" }","title":"9. Generic Functions"},{"location":"09_Generic_Functions/#9-generic-functions","text":"Serene supports both generic functions and generic types. What does that mean? Well, let's start with generic functions, which allow you to write a function without knowing the types of its parameters and return values in advance. You can later specify them when the function is called. In C++, you might see generics that look something like std::make_unique<Node>(data) , where you pass two sets of parameters: the type information in angle brackets, and the initialization data for the constructor in parenthesis. In Serene, you use curly braces instead of angle brackets for the type parameters in the function definition, but you should never actually see both sets of parameters written together when the function is called, as the type parameters are always either inferred or passed explicitly as regular arguments. As we'll see in the next section, the same is true for generic types: you might want to create an array whose type is Array{Int} , but you would initialize it using its constructor (eg. Array(1, 2, 3) ) and the type parameters would be inferred. ( Array{Int}(1, 2, 3) is invalid syntax.) Generic parameters are types, so they must be start with capital letters like any other type in Serene, and they are specified using the type keyword, like in the example below. function elementInArray { T : type } ( move elem: T , arr: Array { T }) -> maybe T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray2 { A : type , B type } ( move elem: A , arr: B ) -> maybe A where A : Simple , B : Array { A } { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } function makeEmptyCellVector { T : type } ( T : type ) -> Vector { Cell { T }} { return Vector ( Cell { T }) // The constructor for vectors allows you to pass a type explicitly } function main () { var a = makeEmptyCellVector( Int ) print a // Prints [] run a.append!( None ) print a // Prints [None] run a.append!(18) print a // Prints [None, 18] var u = Array (1, 3, 5, 7) either ( print elementInArray(5, u)) or print \"Could not be found\" either ( print elementInArray2(7, u)) or print \"Could not be found\" }","title":"9. Generic Functions"},{"location":"10_Generic_Types/","text":"10. Generic Types We've already seen generic types when working with arrays and vectors, but here we'll learn how they work and how to define new ones. As we saw with generic functions, the idea behind generics is that you can define a broad template for how something works without specifying exact types, and then you can provide the type information later. We will introduce generic types through two examples using Regions and Handles. Implementing Regions and Handles Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns a maybe type here because it is possible that there is no valid object for that handle. Region and Handle are part of the standard library, but here's a sample of how they could be implemented. type Handle { MyRegion : type } with ~ constructor ( MyRegion : type , index: Int ) { var self.index private = index } ~ friend Region type Region { T : type } with ~ constructor ( T : type ) { var self.vector private = Vector ( T ) } ~ specifics { method add (new_value: T ) -> Handle { Region { T }} { run self.vector.append( NewValue ) const handle = Handle ( Region { T }, vector.length) return handle } method delete (index_to_delete: Handle { Region { T }}) { run self.vector.pop!(index_to_delete) } subscript get (my_handle: Handle { Region { T }}) -> maybe T { return self.vector[my_handle.index] } } Doubly Linked Lists We've seen a singly linked list implementation, but doubly linked lists can be a bit more difficult in a language with single ownership of objects. However, Regions and Handles make this task manageable, as we can store all of the elements in a Region, and we can use Handles as indexes into that Region, so there is no need for pointers or shared mutability. We also use generics to allow you to specify the type of the data. // Implementation of a doubly linked list // Some issues with \"maybe\" vs. Cell should be fixed type Node { MyHandle : type , Data : type } with ~ constructor (prev: MyHandle , data: Data , next: MyHandle ) { var self.prev = prev var self.data = data var self.next = next } type DoublyLinkedList { Data : type } with ~ constructor ( Data : type ) { var self.nodes private = Region ( Data ) type self.Handle private = self.nodes.Handle var self.head_handle private: Cell { Node } = None var self.tail_handle private: Cell { Node } = None } ~ specifics { method addFirst (a: Data ) { set self.head_handle = self.nodes.add!( Node ( None , a, self.head_handle)) } method addLast (a: Data ) { set self.tail_handle = self.nodes.add!( Node (self.tail_handle, a, None )) } method deleteFirst () { if (self.head_handle is None ) return const x = self.head_handle set self.head_handle = self.nodes[self.head_handle].next run self.nodes.delete!(x) } method deleteLast () { if (self.head_handle is None ) return const x = self.last_handle set self.last_handle = self.nodes[self.last_handle].prev run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Data { return self.nodes[h].data } }","title":"10. Generic Types"},{"location":"10_Generic_Types/#10-generic-types","text":"We've already seen generic types when working with arrays and vectors, but here we'll learn how they work and how to define new ones. As we saw with generic functions, the idea behind generics is that you can define a broad template for how something works without specifying exact types, and then you can provide the type information later. We will introduce generic types through two examples using Regions and Handles.","title":"10. Generic Types"},{"location":"10_Generic_Types/#implementing-regions-and-handles","text":"Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns a maybe type here because it is possible that there is no valid object for that handle. Region and Handle are part of the standard library, but here's a sample of how they could be implemented. type Handle { MyRegion : type } with ~ constructor ( MyRegion : type , index: Int ) { var self.index private = index } ~ friend Region type Region { T : type } with ~ constructor ( T : type ) { var self.vector private = Vector ( T ) } ~ specifics { method add (new_value: T ) -> Handle { Region { T }} { run self.vector.append( NewValue ) const handle = Handle ( Region { T }, vector.length) return handle } method delete (index_to_delete: Handle { Region { T }}) { run self.vector.pop!(index_to_delete) } subscript get (my_handle: Handle { Region { T }}) -> maybe T { return self.vector[my_handle.index] } }","title":"Implementing Regions and Handles"},{"location":"10_Generic_Types/#doubly-linked-lists","text":"We've seen a singly linked list implementation, but doubly linked lists can be a bit more difficult in a language with single ownership of objects. However, Regions and Handles make this task manageable, as we can store all of the elements in a Region, and we can use Handles as indexes into that Region, so there is no need for pointers or shared mutability. We also use generics to allow you to specify the type of the data. // Implementation of a doubly linked list // Some issues with \"maybe\" vs. Cell should be fixed type Node { MyHandle : type , Data : type } with ~ constructor (prev: MyHandle , data: Data , next: MyHandle ) { var self.prev = prev var self.data = data var self.next = next } type DoublyLinkedList { Data : type } with ~ constructor ( Data : type ) { var self.nodes private = Region ( Data ) type self.Handle private = self.nodes.Handle var self.head_handle private: Cell { Node } = None var self.tail_handle private: Cell { Node } = None } ~ specifics { method addFirst (a: Data ) { set self.head_handle = self.nodes.add!( Node ( None , a, self.head_handle)) } method addLast (a: Data ) { set self.tail_handle = self.nodes.add!( Node (self.tail_handle, a, None )) } method deleteFirst () { if (self.head_handle is None ) return const x = self.head_handle set self.head_handle = self.nodes[self.head_handle].next run self.nodes.delete!(x) } method deleteLast () { if (self.head_handle is None ) return const x = self.last_handle set self.last_handle = self.nodes[self.last_handle].prev run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Data { return self.nodes[h].data } }","title":"Doubly Linked Lists"},{"location":"99_Everything_Else/","text":"Everything Else Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene? Concurrency This is an important one, and it's probably the biggest unknown at this point. The concurrency system will likely be closely linked to mutability and ownership, since there will need to be some way of passing data between threads. It won't be as simple as putting a mutex on a shared variable, since the language doesn't have any shared mutable state to begin with. Because of this, concurrency will likely have to be native to the language rather than being a standard library module. (Also, it would benefit readability to have some kind of special syntax that makes the thread synchronization clear.) Perhaps some sort of message passing system will work, but I really haven't started researching anything yet. Hardware Interrupts Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope. Modules It's important for Serene to have a true module system: one that works seamlessly across different platforms and different versions of the language. As far as the syntax goes, I'd like to avoid having things like std::something everywhere. Python allows you to import standard library modules without actually writing std , and you can also import a module and specify whether to bring it into the current namespace in a single statement (rather than separate #include and using statements in C++, for example). I expect that the module syntax will similar to Python's, though with Module::Something for module prefixes instead of Module.Something . I'd also want a better way to differentiate between standard library modules and module files in a local directory. Put all of this together and it'll look something like this: import Math run Math::sqrt(9) from AsyncGUI import Window import local \"lib/MovieReviewTypes.sn\" Error Handling Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system. I frankly don't know that much about error handling and I'm not planning on doing anything particularly innovative here: the error handling system will likely be modeled after Rust or another modern language. Anonymous Functions With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve. Tuning From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it. Many Other Things Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist feature-set, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Everything Else"},{"location":"99_Everything_Else/#everything-else","text":"Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene?","title":"Everything Else"},{"location":"99_Everything_Else/#concurrency","text":"This is an important one, and it's probably the biggest unknown at this point. The concurrency system will likely be closely linked to mutability and ownership, since there will need to be some way of passing data between threads. It won't be as simple as putting a mutex on a shared variable, since the language doesn't have any shared mutable state to begin with. Because of this, concurrency will likely have to be native to the language rather than being a standard library module. (Also, it would benefit readability to have some kind of special syntax that makes the thread synchronization clear.) Perhaps some sort of message passing system will work, but I really haven't started researching anything yet.","title":"Concurrency"},{"location":"99_Everything_Else/#hardware-interrupts","text":"Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope.","title":"Hardware Interrupts"},{"location":"99_Everything_Else/#modules","text":"It's important for Serene to have a true module system: one that works seamlessly across different platforms and different versions of the language. As far as the syntax goes, I'd like to avoid having things like std::something everywhere. Python allows you to import standard library modules without actually writing std , and you can also import a module and specify whether to bring it into the current namespace in a single statement (rather than separate #include and using statements in C++, for example). I expect that the module syntax will similar to Python's, though with Module::Something for module prefixes instead of Module.Something . I'd also want a better way to differentiate between standard library modules and module files in a local directory. Put all of this together and it'll look something like this: import Math run Math::sqrt(9) from AsyncGUI import Window import local \"lib/MovieReviewTypes.sn\"","title":"Modules"},{"location":"99_Everything_Else/#error-handling","text":"Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system. I frankly don't know that much about error handling and I'm not planning on doing anything particularly innovative here: the error handling system will likely be modeled after Rust or another modern language.","title":"Error Handling"},{"location":"99_Everything_Else/#anonymous-functions","text":"With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve.","title":"Anonymous Functions"},{"location":"99_Everything_Else/#tuning","text":"From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it.","title":"Tuning"},{"location":"99_Everything_Else/#many-other-things","text":"Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist feature-set, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Many Other Things"}]}