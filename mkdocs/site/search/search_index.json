{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"#introduction","text":"Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"1_Regions/","text":"Regions Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module // Assume that array is variable length // needs to be an Option type type Handle with ~ constructor(type MyRegion, index: Int) { set self.index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor(type T) { set self.array = Array(T) type R = typeof(self) } ~ struct { array: Array(T) private, } ~ specifics { method add(NewValue: T) -> Handle(R) { run array.append(NewValue) const handle = Handle(Region, array.length) return handle } method delete(IndexToDelete: Handle(R)) { run array.pop!(IndexToDelete) } subscript get(MyHandle: Handle(R)) -> Option(T) { return array[MyHandle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear... // Which to use? type NewType = something() const NewType: type = something()","title":"Regions"},{"location":"1_Regions/#regions","text":"Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module // Assume that array is variable length // needs to be an Option type type Handle with ~ constructor(type MyRegion, index: Int) { set self.index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor(type T) { set self.array = Array(T) type R = typeof(self) } ~ struct { array: Array(T) private, } ~ specifics { method add(NewValue: T) -> Handle(R) { run array.append(NewValue) const handle = Handle(Region, array.length) return handle } method delete(IndexToDelete: Handle(R)) { run array.pop!(IndexToDelete) } subscript get(MyHandle: Handle(R)) -> Option(T) { return array[MyHandle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear... // Which to use? type NewType = something() const NewType: type = something()","title":"Regions"},{"location":"2_Linked-List/","text":"Example: Linked List Here is an example of a singly linked list implementation in Serene: type Node(type N) is struct { data: Int, next: N, } type LinkedList with ~ struct { nodes: Region(Node), Handle: Type private, head: Handle, } ~ constructor(first: Int) { set self.nodes = Region(Node) set self.Handle = nodes.Handle set self.head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst(a: Int) { set self.head = nodes.add!(Node(a, self.head)) } method addLast(a: Int) { if (self.head == None) { set self.head = nodes.add!(Node(a, None)) } else { var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst() { if (self.head == None) return const x = self.head set self.head = nodes[self.head].next run nodes.delete!(x) } method deleteLast() { if (self.head == None) return var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } run nodes.delete!(x) } }","title":"Example: Linked List"},{"location":"2_Linked-List/#example-linked-list","text":"Here is an example of a singly linked list implementation in Serene: type Node(type N) is struct { data: Int, next: N, } type LinkedList with ~ struct { nodes: Region(Node), Handle: Type private, head: Handle, } ~ constructor(first: Int) { set self.nodes = Region(Node) set self.Handle = nodes.Handle set self.head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst(a: Int) { set self.head = nodes.add!(Node(a, self.head)) } method addLast(a: Int) { if (self.head == None) { set self.head = nodes.add!(Node(a, None)) } else { var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst() { if (self.head == None) return const x = self.head set self.head = nodes[self.head].next run nodes.delete!(x) } method deleteLast() { if (self.head == None) return var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } run nodes.delete!(x) } }","title":"Example: Linked List"},{"location":"3_Indexing/","text":"Example: Indexing Here is an example of using the indexing operator on a Handle . To deal with the Option type that is returned, we use the either construct. either will try to execute the statement in parentheses, and if any part of it returns None , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail(L: LinkedList) -> Handle { either (var currentObject = L[L.head]) or return None while (True) { var currentIndex = currentObject.next either (set currentObject = L[currentIndex]) or return currentIndex } } function removeTail(mutate L: LinkedList) { either (var currentObject = L[L.head]) or return while (True) { var currentIndex = currentObject.next either (set currentObject = L[currentIndex]) or break } run L.delete!(currentIndex) } // Error: what happens to currentObject after L.delete!(currentIndex) ?","title":"Example: Indexing"},{"location":"3_Indexing/#example-indexing","text":"Here is an example of using the indexing operator on a Handle . To deal with the Option type that is returned, we use the either construct. either will try to execute the statement in parentheses, and if any part of it returns None , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail(L: LinkedList) -> Handle { either (var currentObject = L[L.head]) or return None while (True) { var currentIndex = currentObject.next either (set currentObject = L[currentIndex]) or return currentIndex } } function removeTail(mutate L: LinkedList) { either (var currentObject = L[L.head]) or return while (True) { var currentIndex = currentObject.next either (set currentObject = L[currentIndex]) or break } run L.delete!(currentIndex) } // Error: what happens to currentObject after L.delete!(currentIndex) ?","title":"Example: Indexing"},{"location":"4_Interfaces/","text":"Interfaces When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String, location: Address, numGuests: Int, accepted: Bool } ~ signatures { method send(recipient: Person), method accept(guests: Int) } type WeddingInvitation with ~ struct { bride: String, groom: String, struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send(recipient: Person) { run recipient.receive(copy self) } method accept(guests: Int) { set self.accepted = True } method parseLocation(address: String) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan(other: X) -> bool method greaterThan(other: X) -> bool subscript get(index: Int) -> Option(X) } ~ specifics where X: Array(Int) { method lessThan(other: Array(Int)) { for (i in 0 .. min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan(other: Array(Int)) { for (i in 0 .. min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get(index: Int) -> Option(Int) from Index(self: Array(type X)) }","title":"Interfaces"},{"location":"4_Interfaces/#interfaces","text":"When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String, location: Address, numGuests: Int, accepted: Bool } ~ signatures { method send(recipient: Person), method accept(guests: Int) } type WeddingInvitation with ~ struct { bride: String, groom: String, struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send(recipient: Person) { run recipient.receive(copy self) } method accept(guests: Int) { set self.accepted = True } method parseLocation(address: String) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan(other: X) -> bool method greaterThan(other: X) -> bool subscript get(index: Int) -> Option(X) } ~ specifics where X: Array(Int) { method lessThan(other: Array(Int)) { for (i in 0 .. min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan(other: Array(Int)) { for (i in 0 .. min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get(index: Int) -> Option(Int) from Index(self: Array(type X)) }","title":"Interfaces"},{"location":"5_Generics/","text":"Generics Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray(move elem: type T, arr: Array(type T)) -> Option(type T) { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Where statement function elementInArray(move elem: type A, arr: type B) -> type A where type A: Simple, type B: Array(A) { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"Generics"},{"location":"5_Generics/#generics","text":"Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray(move elem: type T, arr: Array(type T)) -> Option(type T) { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Where statement function elementInArray(move elem: type A, arr: type B) -> type A where type A: Simple, type B: Array(A) { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"Generics"},{"location":"6_Types/","text":"Types Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person is struct { age: Int, name: String, gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D is tuple { Int, Int, Int } type Address is tuple { Int, // House number String, // Street name } type RainbowColors is enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"Types"},{"location":"6_Types/#types","text":"Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person is struct { age: Int, name: String, gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D is tuple { Int, Int, Int } type Address is tuple { Int, // House number String, // Street name } type RainbowColors is enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"Types"}]}