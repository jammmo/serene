{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"#introduction","text":"Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"00_Why_Serene/","text":"Why Serene? \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2014Martin Fowler, 1999 If you do a Google search for \"What programming language should people learn first?\" in 2021, you'll see a lot of results for Python. Indeed, my first college computer science class several years ago was taught in Python, after they had switched from teaching MATLAB in previous years. While systems programming languages like C and C++ continue to be widely used within the industry, they are often taught later on and seen to be more difficult than high level languages like Python. The term \"systems programming language\" has always been a bit vague, as many of the characteristic features, like static type checking, efficient optimizing compilers, support for concurrency, and low-overhead memory management, are still desirable for all kinds of general purpose programming. These advantages may lead one to wonder why systems programming languages aren't taught and used everywhere. But Python, which lacks nearly all these features, continues to be a popular choice for both beginners and for fast prototyping of applications due to better readability. Python's syntax often closely mirrors a natural English description of a process, while C is dense with symbols and abbreviations. But beyond syntax, the complexity of manual memory management in C can lead to a mismatch between how someone's code actually behaves and how they expect it to behave, and the language has few safeguards to prevent you from breaking things. Rust, a newer systems programming language, introduced a new memory management system based around ownership of objects, which provides those safeguards by default. But it is still quite complex, and an inaccurate mental model of how the system works can lead to a frustrating experience trying to get your code to compile. Serene is a systems programming language designed to be naturally understood. It uses an ownership-based memory management system inspired by Rust, but it constrains the system to a simpler subset of the same idea. It uses keywords instead of symbols for common operations, and it has a minimalist design so there are less concepts to memorize. Serene is rather strict about its rules, but that leads to a consistent and organized procedural style for all of its code, where one can read and understand each function independently of any other code. It is the goal of the language to make the process of developing high performance software effortless, enjoyable, and\u2014well, serene.","title":"Why Serene?"},{"location":"00_Why_Serene/#why-serene","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2014Martin Fowler, 1999 If you do a Google search for \"What programming language should people learn first?\" in 2021, you'll see a lot of results for Python. Indeed, my first college computer science class several years ago was taught in Python, after they had switched from teaching MATLAB in previous years. While systems programming languages like C and C++ continue to be widely used within the industry, they are often taught later on and seen to be more difficult than high level languages like Python. The term \"systems programming language\" has always been a bit vague, as many of the characteristic features, like static type checking, efficient optimizing compilers, support for concurrency, and low-overhead memory management, are still desirable for all kinds of general purpose programming. These advantages may lead one to wonder why systems programming languages aren't taught and used everywhere. But Python, which lacks nearly all these features, continues to be a popular choice for both beginners and for fast prototyping of applications due to better readability. Python's syntax often closely mirrors a natural English description of a process, while C is dense with symbols and abbreviations. But beyond syntax, the complexity of manual memory management in C can lead to a mismatch between how someone's code actually behaves and how they expect it to behave, and the language has few safeguards to prevent you from breaking things. Rust, a newer systems programming language, introduced a new memory management system based around ownership of objects, which provides those safeguards by default. But it is still quite complex, and an inaccurate mental model of how the system works can lead to a frustrating experience trying to get your code to compile. Serene is a systems programming language designed to be naturally understood. It uses an ownership-based memory management system inspired by Rust, but it constrains the system to a simpler subset of the same idea. It uses keywords instead of symbols for common operations, and it has a minimalist design so there are less concepts to memorize. Serene is rather strict about its rules, but that leads to a consistent and organized procedural style for all of its code, where one can read and understand each function independently of any other code. It is the goal of the language to make the process of developing high performance software effortless, enjoyable, and\u2014well, serene.","title":"Why Serene?"},{"location":"01_Functions/","text":"1. Functions Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. In Serene, the body of a function is a sequence of statements, each beginning with a keyword. printLine on its own isn't a statement, but we use the run keyword to execute it. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) } function main () { run invert(True) //return value is discarded run printLine(invert(True)) //return value is passed to printLine }","title":"1. Functions"},{"location":"01_Functions/#1-functions","text":"Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. In Serene, the body of a function is a sequence of statements, each beginning with a keyword. printLine on its own isn't a statement, but we use the run keyword to execute it. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) } function main () { run invert(True) //return value is discarded run printLine(invert(True)) //return value is passed to printLine }","title":"1. Functions"},{"location":"02_Variables_Types_And_Math/","text":"2. Variables, Types, and Math You can store a value with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). The value of a variable can be modified after it is created with the keyword set , but the value of a constant can never change. Note that variables and constants must be defined inside of functions, and they are locally scoped: that is, they are only valid in the scope in which they are declared. When that scope ends, all of its local values will be deleted and the associated memory will be freed. function test1 () { const age: Int = 20 run printLine(age) //age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 //same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"02_Variables_Types_And_Math/#2-variables-types-and-math","text":"You can store a value with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). The value of a variable can be modified after it is created with the keyword set , but the value of a constant can never change. Note that variables and constants must be defined inside of functions, and they are locally scoped: that is, they are only valid in the scope in which they are declared. When that scope ends, all of its local values will be deleted and the associated memory will be freed. function test1 () { const age: Int = 20 run printLine(age) //age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 //same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"03_Mutability_And_Ownership/","text":"3. Mutability and Ownership Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming. How to Manage Mutability and Ownership You've already seen const , which allows you to create a locally-scoped constant, and var , which allows to create a locally-scoped variable (that can be mutated with set ). Now let's talk about the other place where mutability is important: function parameters. When passing a value to a function, there are four ways you can do it. You need to specify which one to use both where the function is defined and where it is called, using accessor keywords. Let's look at the four different accessors one by one. look : Look is the default behavior for function parameters, so there's no keyword required. It passes a value to a function immutably, meaning that the value cannot be altered anywhere in the function, regardless of whether the value you are passing is a literal value, a var , or a const . This also means that if function a() takes a value by look , function a() can't pass that value to a function b() that takes it by mutate or move . It can, however, pass that value to another function by copy , as copying a value leaves the original value unaffected. mutate : Mutate effectively \"borrows\" the value from its original scope, allowing it to be mutated within the function as if it is a local variable. Once the function returns, ownership of the (now modified) value will return to the original scope. mutate is really the only place that aliasing behavior (where mutating one variable also mutates another) exists in Serene. This behavior can be confusing in other languages (which is part of why Serene doesn't have pointers), but Serene makes the behavior explicit to the reader by requiring the keyword mutate both where the function is defined and where it is called. Note that you can't past a constant ( const ) as a mutate parameter, as once a constant is created, it can never be mutated. Also if function a() takes a value by mutate , function a() still can't pass that value to a function b() that takes it by move , as the value must still exist when the function returns. move : If you've used Rust or modern C++, you've probably heard of Move semantics. move transfers ownership of an object from one scope to another. If you pass a variable to a function by move , that variable won't exist anymore when the function returns. You can move both variables and constants. If you move a variable into a function, that function will be able to mutate the variable with set , just as if it was declared locally. copy : Copy does exactly what it sounds like: it copies the original value and passes the copied value to the function. The original value will be unaffected and it will still be owned by the original scope, while the new value will be owned by the new scope. It's worth mentioning at this point that all four of these accessors describe the user-level semantic behavior, but not necessarily the way that the program will execute at the hardware level. The Serene compiler will optimize the program, and part of that process is removing unnecessary copies. So if you pass a large object by copy but then you never mutate it, the compiler will be smart enough to not waste memory by copying the object and to just use a pointer to the original object. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { // Exclamation marks are required for methods that mutate the object they act on run s.delete!(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name // copies name run removeChar( mutate newname, c) }","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#3-mutability-and-ownership","text":"Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#how-to-manage-mutability-and-ownership","text":"You've already seen const , which allows you to create a locally-scoped constant, and var , which allows to create a locally-scoped variable (that can be mutated with set ). Now let's talk about the other place where mutability is important: function parameters. When passing a value to a function, there are four ways you can do it. You need to specify which one to use both where the function is defined and where it is called, using accessor keywords. Let's look at the four different accessors one by one. look : Look is the default behavior for function parameters, so there's no keyword required. It passes a value to a function immutably, meaning that the value cannot be altered anywhere in the function, regardless of whether the value you are passing is a literal value, a var , or a const . This also means that if function a() takes a value by look , function a() can't pass that value to a function b() that takes it by mutate or move . It can, however, pass that value to another function by copy , as copying a value leaves the original value unaffected. mutate : Mutate effectively \"borrows\" the value from its original scope, allowing it to be mutated within the function as if it is a local variable. Once the function returns, ownership of the (now modified) value will return to the original scope. mutate is really the only place that aliasing behavior (where mutating one variable also mutates another) exists in Serene. This behavior can be confusing in other languages (which is part of why Serene doesn't have pointers), but Serene makes the behavior explicit to the reader by requiring the keyword mutate both where the function is defined and where it is called. Note that you can't past a constant ( const ) as a mutate parameter, as once a constant is created, it can never be mutated. Also if function a() takes a value by mutate , function a() still can't pass that value to a function b() that takes it by move , as the value must still exist when the function returns. move : If you've used Rust or modern C++, you've probably heard of Move semantics. move transfers ownership of an object from one scope to another. If you pass a variable to a function by move , that variable won't exist anymore when the function returns. You can move both variables and constants. If you move a variable into a function, that function will be able to mutate the variable with set , just as if it was declared locally. copy : Copy does exactly what it sounds like: it copies the original value and passes the copied value to the function. The original value will be unaffected and it will still be owned by the original scope, while the new value will be owned by the new scope. It's worth mentioning at this point that all four of these accessors describe the user-level semantic behavior, but not necessarily the way that the program will execute at the hardware level. The Serene compiler will optimize the program, and part of that process is removing unnecessary copies. So if you pass a large object by copy but then you never mutate it, the compiler will be smart enough to not waste memory by copying the object and to just use a pointer to the original object. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { // Exclamation marks are required for methods that mutate the object they act on run s.delete!(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name // copies name run removeChar( mutate newname, c) }","title":"How to Manage Mutability and Ownership"},{"location":"04_Collections/","text":"4. Collections In this section, we will learn about several more complex types that are built into Serene. Arrays An array is a fixed-length sequence elements, where all of the elements are the same type. If the index is invalid, the indexing operation will return undefined , which is a special value (actually, it's not a value) that will be introduced later, in the Expressing Nothing section. You specify what the types of elements are by using generics. We'll explain more about generics later, but for now it suffices to say that you put the type of the elements in curly braces. So Array{Float} would be an array of floating-point numbers. // returns the index of the leftmost occurence of x, or the next lowest number if x is not found // Array u must be already sorted function binarySearch (u: Array {Int}, x: Int ) -> Int { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 // integer division either (u[mid] is defined) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } return low } function main () { var u = Array(5, 1, 4, -3, 9, 0) run u.sort!() run printLine(binarySearch(u, 4)) } Vectors An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . // deletes the leftmost occurence of x, or does nothing if x is not found // Vector u must be already sorted function binarySearchAndDelete ( mutate u: Vector {Int}, x: Int ) { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 either (u[mid] is defined) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } if (u[low] == x) { run u.delete!(low) } } function main () { var u = Vector(Int) // creates an empty vector of integers run printline( \"Length of u: %\" , u.length) // Length of u: 0 for (i = 0, 5) { u.append!(i * 2) } run printline( \"Length of u: %\" , u.length) // Length of u: 5 run printLine(u) // [0, 2, 4, 6, 8] run printLine(binarySearch(u, 6)) // 3 } Regions (and Handles) A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region{String} const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) // You can run multiple functions on the same line run printLine(reg[firstName]), printLine(reg[middleName]), printLine(reg[lastName]) } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region {String} { var reg = Region{String} const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) return reg }","title":"4. Collections"},{"location":"04_Collections/#4-collections","text":"In this section, we will learn about several more complex types that are built into Serene.","title":"4. Collections"},{"location":"04_Collections/#arrays","text":"An array is a fixed-length sequence elements, where all of the elements are the same type. If the index is invalid, the indexing operation will return undefined , which is a special value (actually, it's not a value) that will be introduced later, in the Expressing Nothing section. You specify what the types of elements are by using generics. We'll explain more about generics later, but for now it suffices to say that you put the type of the elements in curly braces. So Array{Float} would be an array of floating-point numbers. // returns the index of the leftmost occurence of x, or the next lowest number if x is not found // Array u must be already sorted function binarySearch (u: Array {Int}, x: Int ) -> Int { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 // integer division either (u[mid] is defined) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } return low } function main () { var u = Array(5, 1, 4, -3, 9, 0) run u.sort!() run printLine(binarySearch(u, 4)) }","title":"Arrays"},{"location":"04_Collections/#vectors","text":"An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . // deletes the leftmost occurence of x, or does nothing if x is not found // Vector u must be already sorted function binarySearchAndDelete ( mutate u: Vector {Int}, x: Int ) { var low = 0 var high = u.length while (low < high) { var mid = (low + high) / 2 either (u[mid] is defined) or throw IndexError if (u[mid] < x) { set high = mid } else { set low = mid + 1 } } if (u[low] == x) { run u.delete!(low) } } function main () { var u = Vector(Int) // creates an empty vector of integers run printline( \"Length of u: %\" , u.length) // Length of u: 0 for (i = 0, 5) { u.append!(i * 2) } run printline( \"Length of u: %\" , u.length) // Length of u: 5 run printLine(u) // [0, 2, 4, 6, 8] run printLine(binarySearch(u, 6)) // 3 }","title":"Vectors"},{"location":"04_Collections/#regions-and-handles","text":"A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region{String} const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) // You can run multiple functions on the same line run printLine(reg[firstName]), printLine(reg[middleName]), printLine(reg[lastName]) } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region {String} { var reg = Region{String} const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) return reg }","title":"Regions (and Handles)"},{"location":"05_Control_Flow/","text":"5. Control Flow So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs. Conditional Statements A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) -> Int { if (x < 0) { return -x } else { return x } } Loops Serene has two looping constructs: \"for loops\" and \"while loops\". function findMax (u: Vector {Int}) -> Int { var max = Int.bottom //lowest possible Int value for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector {Int}) -> Int { var max = Int.bottom for (i = 0, u.length) { //iterates from 0 up to (but not including) the length of u // Compiler automatically checks that u[i] is not undefined by verifying the loop bounds if (u[i] > max) { set max = u[i] } } } function findMax3 (u: Vector {Int}) -> Int { var max = Int.bottom var i: Int = 0 while (i < u.length) { if (u[i] > max) { set max = u[i] } } } Match A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } } More Control Flow There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"5. Control Flow"},{"location":"05_Control_Flow/#5-control-flow","text":"So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs.","title":"5. Control Flow"},{"location":"05_Control_Flow/#conditional-statements","text":"A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) -> Int { if (x < 0) { return -x } else { return x } }","title":"Conditional Statements"},{"location":"05_Control_Flow/#loops","text":"Serene has two looping constructs: \"for loops\" and \"while loops\". function findMax (u: Vector {Int}) -> Int { var max = Int.bottom //lowest possible Int value for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector {Int}) -> Int { var max = Int.bottom for (i = 0, u.length) { //iterates from 0 up to (but not including) the length of u // Compiler automatically checks that u[i] is not undefined by verifying the loop bounds if (u[i] > max) { set max = u[i] } } } function findMax3 (u: Vector {Int}) -> Int { var max = Int.bottom var i: Int = 0 while (i < u.length) { if (u[i] > max) { set max = u[i] } } }","title":"Loops"},{"location":"05_Control_Flow/#match","text":"A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } }","title":"Match"},{"location":"05_Control_Flow/#more-control-flow","text":"There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"More Control Flow"},{"location":"06_Expressing_Nothing/","text":"6. Expressing Nothing There are a couple ways of expressing that something does not exist in Serene. Maybe (Defined and Undefined) The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values. This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but function parameters cannot be undefined. Also, once you have checked that a value is defined, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } } Either The either statement is used to handle values that may be undefined. Here is an example of using the indexing operator with a Handle . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> maybe Handle { either ( var currentObject = u[u.head]) or return undefined while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) } Cell While it isn't present for maybe types, the \"unwrapping\" behavior of something like Option in Rust is still useful in certain situations. For that, Serene provides the Cell type, which can be unwrapped into either Some(x) or Empty .","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#6-expressing-nothing","text":"There are a couple ways of expressing that something does not exist in Serene.","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#maybe-defined-and-undefined","text":"The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values. This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but function parameters cannot be undefined. Also, once you have checked that a value is defined, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } }","title":"Maybe (Defined and Undefined)"},{"location":"06_Expressing_Nothing/#either","text":"The either statement is used to handle values that may be undefined. Here is an example of using the indexing operator with a Handle . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> maybe Handle { either ( var currentObject = u[u.head]) or return undefined while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) }","title":"Either"},{"location":"06_Expressing_Nothing/#cell","text":"While it isn't present for maybe types, the \"unwrapping\" behavior of something like Option in Rust is still useful in certain situations. For that, Serene provides the Cell type, which can be unwrapped into either Some(x) or Empty .","title":"Cell"},{"location":"07_Custom_Types/","text":"7. Custom Types Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: Cell {String} } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple } Linked List Example Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it. Internally, it stores data as a struct, but instead of passing the fields of the struct directly, the user will pass arguments to a constructor function which will create and initialize the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. This format is called a \"constructed type\". One new thing here is private fields, which can't be accessed from outside of the type's definition. However, a type can give special permission for another type to access its private fields by declaring it a friend type, as we will see later. // Linked list of integers type Node{MyHandle: type } with ~ constructor(data: Int , next: MyHandle ) { var self.data: Int var self.next: MyHandle } type LinkedList with ~ constructor(first: Int ) { var self.nodes private = Region(Int) type self.Handle private = self.nodes.Handle var self.head private = self.nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set self.head = self.nodes.add!(Node(a, self.head)) } method addLast (a: Int ) { if (self.head is Empty) { set self.head = self.nodes.add!(Node(a, None)) } else { var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } set x.next = self.nodes.add!(Node(a, None)) } } method deleteFirst () { if (self.head is Empty) return const x = self.head set self.head = self.nodes[self.head].next run self.nodes.delete!(x) } method deleteLast () { if (self.head is Empty) return var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Int { return self.nodes[h] } }","title":"7. Custom Types"},{"location":"07_Custom_Types/#7-custom-types","text":"Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: Cell {String} } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"7. Custom Types"},{"location":"07_Custom_Types/#linked-list-example","text":"Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it. Internally, it stores data as a struct, but instead of passing the fields of the struct directly, the user will pass arguments to a constructor function which will create and initialize the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. This format is called a \"constructed type\". One new thing here is private fields, which can't be accessed from outside of the type's definition. However, a type can give special permission for another type to access its private fields by declaring it a friend type, as we will see later. // Linked list of integers type Node{MyHandle: type } with ~ constructor(data: Int , next: MyHandle ) { var self.data: Int var self.next: MyHandle } type LinkedList with ~ constructor(first: Int ) { var self.nodes private = Region(Int) type self.Handle private = self.nodes.Handle var self.head private = self.nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set self.head = self.nodes.add!(Node(a, self.head)) } method addLast (a: Int ) { if (self.head is Empty) { set self.head = self.nodes.add!(Node(a, None)) } else { var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } set x.next = self.nodes.add!(Node(a, None)) } } method deleteFirst () { if (self.head is Empty) return const x = self.head set self.head = self.nodes[self.head].next run self.nodes.delete!(x) } method deleteLast () { if (self.head is Empty) return var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Int { return self.nodes[h] } }","title":"Linked List Example"},{"location":"08_Interfaces/","text":"8. Interfaces When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. interface Invitation with ~ signatures { method send (recipient: Person ) method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , date: String , location: Address , numGuests: Int , accepted: Bool } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } // Use implementation of method from a separate module method parseLocation (address: String ) from Address }","title":"8. Interfaces"},{"location":"08_Interfaces/#8-interfaces","text":"When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. interface Invitation with ~ signatures { method send (recipient: Person ) method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , date: String , location: Address , numGuests: Int , accepted: Bool } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } // Use implementation of method from a separate module method parseLocation (address: String ) from Address }","title":"8. Interfaces"},{"location":"09_Generic_Functions/","text":"9. Generic Functions Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray {T: type } ( move elem: T , arr: Array {T}) -> maybe T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray2 {A: type , B type } ( move elem: A , arr: B ) -> maybe A where A: Simple , B: Array {A} { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } function main () { var u = Array(1, 3, 5, 7) either ( run printLine(elementInArray(5, u)) or run printLine( \"Could not be found\" ) either ( run printLine(elementInArray2(7, u)) or run printLine( \"Could not be found\" ) }","title":"9. Generic Functions"},{"location":"09_Generic_Functions/#9-generic-functions","text":"Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray {T: type } ( move elem: T , arr: Array {T}) -> maybe T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray2 {A: type , B type } ( move elem: A , arr: B ) -> maybe A where A: Simple , B: Array {A} { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } function main () { var u = Array(1, 3, 5, 7) either ( run printLine(elementInArray(5, u)) or run printLine( \"Could not be found\" ) either ( run printLine(elementInArray2(7, u)) or run printLine( \"Could not be found\" ) }","title":"9. Generic Functions"},{"location":"10_Generic_Types/","text":"10. Generic Types We will introduce generic types through a new implementation of linked lists, followed by an example using Regions and Handles, two commonly used standard library types. More Linked Lists Here is a linked list implementation similar to the one we've seen before, except now it uses generics to allow you to specify the type of the data. type Node{MyHandle: type , Data: type } with ~ constructor(data: Data , next: MyHandle ) { var self.data = data var self.next = next } type LinkedList{Data: type } with ~ constructor(first: Data ) { var self.nodes private = Region(Data) type self.Handle private = self.nodes.Handle var self.head private = self.nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Data ) { set self.head = self.nodes.add!(Node(a, self.head)) } method addLast (a: Data ) { if (self.head is Empty) { set self.head = self.nodes.add!(Node(a, None)) } else { var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } set x.next = self.nodes.add!(Node(a, None)) } } method deleteFirst () { if (self.head is Empty) return const x = self.head set self.head = self.nodes[self.head].next run self.nodes.delete!(x) } method deleteLast () { if (self.head is Empty) return var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Data { return self.nodes[h] } } Regions and Handles Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns a maybe type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. type Handle{MyRegion: type } with ~ constructor(MyRegion: type , index: Int ) { var self.index private = index } ~ friend Region type Region{T: type } with ~ constructor(T: type ) { var self.vector private: Vector {T} = Vector() } ~ specifics { method add (new_value: T ) -> Handle {Region{T}} { run self.vector.append(NewValue) const handle = Handle(Region{T}, vector.length) return handle } method delete (index_to_delete: Handle {Region{T}}) { run self.vector.pop!(index_to_delete) } subscript get (my_handle: Handle {Region{T}}) -> maybe T { return self.vector[my_handle.index] } }","title":"10. Generic Types"},{"location":"10_Generic_Types/#10-generic-types","text":"We will introduce generic types through a new implementation of linked lists, followed by an example using Regions and Handles, two commonly used standard library types.","title":"10. Generic Types"},{"location":"10_Generic_Types/#more-linked-lists","text":"Here is a linked list implementation similar to the one we've seen before, except now it uses generics to allow you to specify the type of the data. type Node{MyHandle: type , Data: type } with ~ constructor(data: Data , next: MyHandle ) { var self.data = data var self.next = next } type LinkedList{Data: type } with ~ constructor(first: Data ) { var self.nodes private = Region(Data) type self.Handle private = self.nodes.Handle var self.head private = self.nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Data ) { set self.head = self.nodes.add!(Node(a, self.head)) } method addLast (a: Data ) { if (self.head is Empty) { set self.head = self.nodes.add!(Node(a, None)) } else { var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } set x.next = self.nodes.add!(Node(a, None)) } } method deleteFirst () { if (self.head is Empty) return const x = self.head set self.head = self.nodes[self.head].next run self.nodes.delete!(x) } method deleteLast () { if (self.head is Empty) return var x = self.nodes[self.head] while (self.nodes[x.next] is defined) { set x = self.nodes[x.next] } run self.nodes.delete!(x) } subscript get (h: Handle ) -> maybe Data { return self.nodes[h] } }","title":"More Linked Lists"},{"location":"10_Generic_Types/#regions-and-handles","text":"Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns a maybe type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. type Handle{MyRegion: type } with ~ constructor(MyRegion: type , index: Int ) { var self.index private = index } ~ friend Region type Region{T: type } with ~ constructor(T: type ) { var self.vector private: Vector {T} = Vector() } ~ specifics { method add (new_value: T ) -> Handle {Region{T}} { run self.vector.append(NewValue) const handle = Handle(Region{T}, vector.length) return handle } method delete (index_to_delete: Handle {Region{T}}) { run self.vector.pop!(index_to_delete) } subscript get (my_handle: Handle {Region{T}}) -> maybe T { return self.vector[my_handle.index] } }","title":"Regions and Handles"},{"location":"99_Everything_Else/","text":"Everything Else Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene? Concurrency This is an important one, and it's probably the biggest unknown at this point. The concurrency system will likely be closely linked to mutability and ownership, since there will need to be some way of passing data between threads. It won't be as simple as putting a mutex on a shared variable, since the language doesn't have any shared mutable state to begin with. Because of this, concurrency will likely have to be native to the language rather than being a standard library module. (Also, it would benefit readability to have some kind of special syntax that makes the thread synchronization clear.) Perhaps some sort of message passing system will work, but I really haven't started researching anything yet. Hardware Interrupts Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope. Modules It's important for Serene to have a true module system: one that works seamlessly across different platforms and different versions of the language. As far as the syntax goes, I'd like to avoid having things like std::something everywhere. Python allows you to import standard library modules without actually writing std , and you can also import a module and specify whether to bring it into the current namespace in a single statement (rather than separate #include and using statements in C++, for example). I expect that the module syntax will similar to Python's, though with Module::Something for module prefixes instead of Module.Something . I'd also want a better way to differentiate between standard library modules and module files in a local directory. Put all of this together and it'll look something like this: import Math run Math::sqrt(9) from AsyncGUI import Window import local \"lib/MovieReviewTypes.sn\" Error Handling Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system. I frankly don't know that much about error handling and I'm not planning on doing anything particularly innovative here: the error handling system will likely be modeled after Rust or another modern language. Anonymous Functions With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve. Tuning From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it. Many Other Things Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist feature-set, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Everything Else"},{"location":"99_Everything_Else/#everything-else","text":"Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene?","title":"Everything Else"},{"location":"99_Everything_Else/#concurrency","text":"This is an important one, and it's probably the biggest unknown at this point. The concurrency system will likely be closely linked to mutability and ownership, since there will need to be some way of passing data between threads. It won't be as simple as putting a mutex on a shared variable, since the language doesn't have any shared mutable state to begin with. Because of this, concurrency will likely have to be native to the language rather than being a standard library module. (Also, it would benefit readability to have some kind of special syntax that makes the thread synchronization clear.) Perhaps some sort of message passing system will work, but I really haven't started researching anything yet.","title":"Concurrency"},{"location":"99_Everything_Else/#hardware-interrupts","text":"Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope.","title":"Hardware Interrupts"},{"location":"99_Everything_Else/#modules","text":"It's important for Serene to have a true module system: one that works seamlessly across different platforms and different versions of the language. As far as the syntax goes, I'd like to avoid having things like std::something everywhere. Python allows you to import standard library modules without actually writing std , and you can also import a module and specify whether to bring it into the current namespace in a single statement (rather than separate #include and using statements in C++, for example). I expect that the module syntax will similar to Python's, though with Module::Something for module prefixes instead of Module.Something . I'd also want a better way to differentiate between standard library modules and module files in a local directory. Put all of this together and it'll look something like this: import Math run Math::sqrt(9) from AsyncGUI import Window import local \"lib/MovieReviewTypes.sn\"","title":"Modules"},{"location":"99_Everything_Else/#error-handling","text":"Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system. I frankly don't know that much about error handling and I'm not planning on doing anything particularly innovative here: the error handling system will likely be modeled after Rust or another modern language.","title":"Error Handling"},{"location":"99_Everything_Else/#anonymous-functions","text":"With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve.","title":"Anonymous Functions"},{"location":"99_Everything_Else/#tuning","text":"From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it.","title":"Tuning"},{"location":"99_Everything_Else/#many-other-things","text":"Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist feature-set, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Many Other Things"}]}